# Java SE 01



## Chapter02  Java 概述



- JDK、JRE、JVM的关系
  1. JDK = JRE + java开发工具集
  2. JRE = JVM + JavaSE标准类库(java核心类库)



- 环境变量path配置及其作用
  1. 作用：是为了在dos的任意目录，可以去使用javac和java等命令
  2. 先配置 JAVA_HOME = 指向jdk安装的主目录
  3. 编辑path环境变量，增加 %JAVA_HOME%\bin



- java编写步骤
  1. 编写java源代码 .java
  2. javac 编译，得到对应的 .class 字节码文件
  3. java 运行，本质就是把 .class 加载到jvm 运行



- java编写7个规范
  1. 类、方法的注释，使用javadoc的方式，即文档注释
  2. 非javadoc注释，是对代码的说明(给程序维护者看的)，说明为什么这么写、如何修改、注意事项
  3. 使用tab，将代码整体右移；shift+tab 整体左移
  4. 运算符和 = 的两边，给空格，代码看上去清楚，比如 int n = a + b;
  5. 源文件使用 utf-8 编码
  6. 行宽度不超过80字符
  7. 代码编写次行风格和行尾风格(推荐)



## Chapter03  变量

### 变量介绍

- 变量是程序的基本组成单位

- 变量三要素：数据类型、变量名、值

- 变量表示内存中的一个存储区域，通过变量名可以访问到变量(值)

  

### 程序中 +号的使用

- 左右两边都是数值型，做加法运算

- 左右两边有一方为字符串，做拼接运算

- 运算顺序是，从左到右

  

### 数据类型

- 基本数据类型
  - 数值型
    - 整数类型 byte[1], short[2], int[4], long[8]
    - 浮点（小数）类型 float[4], double[8]
  - 字符型 char[2]
  - 布尔型 boolean[1]
- 引用数据类型
  - 类（class）
  - 接口（interface）
  - 数组（array）



**整数类型**

|      类型      | 占用存储空间 |       范围        |
| :------------: | :----------: | :---------------: |
|  byte [字节]   |    1字节     |    -128 ~ 127     |
| short [短整型] |    2字节     | -(2^15^) ~2^15^-1 |
|   int [整型]   |    4字节     | -(2^31^) ~2^31^-1 |
| long [长整型]  |    8字节     | -(2^63^) ~2^63^-1 |

1. java 的整型常量默认为 int 型，声明 long 型常量，须后加 'l' 或 'L'



**浮点类型**

|     类型      | 占用存储空间 |          范围          |
| :-----------: | :----------: | :--------------------: |
| 单精度 float  |    4字节     |  -3.403E38 ~ 3.403E38  |
| 双精度 double |    8字节     | -1.798E308 ~ 1.798E308 |

1. 浮点数在机器中存放形式：浮点数 = 符号位 + 指数位 +尾数位
2. 尾数部分可能丢失，造成精度损失（小数都是近似值）
3. java 的浮点型常量默认为 double 型，声明 float 型常量，须后加 'f' 或 'F'
4. 通常情况下，应该使用double型，因为它比float型更精确。
5. 浮点型常量有两种表示形式
   - 十进制数：5.12   512.0f   .512
   - 科学计数法：5.12e2   5.12E-2
6. 浮点数使用陷阱：2.7 和 8.1/3 比较

​       当我们对运算结果是小数的进行相等判断时，应该是以两个数的差值的绝对值 abs，在某个精度范围内判断。

​     （如果是直接查询得到的小数或者直接赋值的小数，可以进行相等 == 判断）

```java
double num1 = 2.7;
double num2 = 8.1 / 3;
if(Math.abs(num1 - num2) < 0.000001 ) {
	System.out.println("差值非常小，到我的规定精度，认为相等...");
}
```



**字符类型**

- 字符编码表
  - ASCII
  - Unicode
  - utf-8
  - gbk



**布尔类型**

- 只允许取值 true 和 false
- boolean 类型适于逻辑运算，一般用于程序流程控制
- 不可以用0或非0的整数替代 false和 true，这点和C语言不同



### Java API 文档

- Java 类的组织形式
- 如何使用
  - 包 - > 类 -> 方法
  - 直接索引（检索）



### 基本数据类型转换

- 自动类型转换

  - 当 java 程序在进行赋值或运算时，精度小的类型自动转换为精度大的类型
  - 数据类型按精度（容量）大小排序为：

  ​       char -> int -> long -> float -> double

  ​       byte -> short -> int -> long -> float -> double

  - 细节

    1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
    2. 当把精度大的类型赋值给精度小的类型时，就会报错，反之就会进行自动类型转换。
    3. (byte, short) 和 char 之间不会相互自动转换
    4. byte, short, char  参与运算，在计算时首先转换为 int 类型
    5. boolean 不参与类型的自动转换
    6. 自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型

    ```java
    int num = 'c';//97
    double d = 80;//80.0
    
    byte b1 = 1;
    byte b2 = 2;
    short s1 = 5;
    int n1 = b1 + b2;
    int n2 = b1 + s1;
    ```

    

- 强制类型转换

  - 自动类型转换的逆过程，将容量大的类型转换为容量小的类型。
  - 使用时要加上强制转换符 ( )，但可能造成精度降低或溢出。



### 基本数据类型和 String 类型的转换

```java
//基本数据类型->String
int n1 = 100;
float f1 = 1.1F;
double d1 = 4.5;
boolean b1 = true;
//基本数据类型的值 + ""
String s1 = n1 + "";
String s2 = f1 + "";
String s3 = d1 + "";
String s4 = b1 + "";


//String->对应的基本数据类型
String s5 = "123";
//使用 基本数据类型对应的包装类，调用 parseXX 方法
int num1 = Integer.parseInt(s5);
double num2 = Double.parseDouble(s5);
float num3 = Float.parseFloat(s5);
long num4 = Long.parseLong(s5);
byte num5 = Byte.parseByte(s5);
short num6 = Short.parseShort(s5);
boolean b = Boolean.parseBoolean("true");
//把字符串转成字符char -> 含义是指 得到字符串的第一个字符
System.out.println(s5.charAt(0));

```



## Chapter04 运算符

### 算术运算符 arithmetic operator

- 正负号：+ -

- 加减乘除：+ - * /

- 取模（取余）：%

  ```java
  // % 的本质 公式!  a % b = a - a / b * b
  //-10 % 3 = -1
  //10 % -3 = 1
  //-10 % -3 = -1
  
  //a % b 当 a 是小数时，公式 a % b = a - (int)a / b * b
  //-10.5 % 3 = -10.5 - (-10) / 3 * 3 = -10.5 + 9 = -1.5
  //注意：有小数参与运算，得到的结果是近似值
  ```

- 自增/减（前/后）：++   --

- 字符串相加：+



### 关系运算符 relational operator

- ==   !=
- <   >
- <=    >=
- instanceof

1. 关系运算符的结果都是 boolean 值，**true** or **false**

2. 关系运算符组成的表达式，称为**关系表达式**

   

### 逻辑运算符 logic operator

> 用于连接多个条件（多个关系表达式），最终的结果是一个 boolean 值。

| 逻辑运算符 |      语法      | 运算规则                                                     |
| :--------: | :------------: | :----------------------------------------------------------- |
| 短路与 &&  | 条件1 && 条件2 | 两个条件都为true，结果为true，否则false。<br />如果第一个条件为false，后面的条件不再判断。效率高 |
|  逻辑与 &  | 条件1 & 条件2  | 两个条件都为true，结果为true，否则false。<br />如果第一个条件为false，后面的条件仍然会判断。 |

| 逻辑运算符  |       语法       | 运算规则                                                     |
| :---------: | :--------------: | ------------------------------------------------------------ |
| 短路或 \|\| | 条件1 \|\| 条件2 | 只要有一个成立，结果为true，否则false。<br />如果第一个条件为true，则第二个条件不会判断，最终结果为true。效率高 |
|  逻辑或 \|  |  条件1 \| 条件2  | 只要有一个条件成立，结果为true，否则false。<br />不管第一个条件是否为true，第二个条件都要判断。 |

|  逻辑运算符  | 语法  | 运算规则                                    |
| :----------: | :---: | ------------------------------------------- |
| 非（取反） ! | !条件 | 如果条件本身成立，结果为false，否则为true。 |
| 逻辑异或 a^b | a ^ b | 当a 和b 不同时，则结果为true，否则为false。 |



### 赋值运算符 assign operator

> 赋值运算符就是将某个运算后的值，赋给指定的变量。

- 基本赋值运算符：=   
- 复合赋值运算符：+=，-=，*=，/=，%= 
- 特点
  1. 运算顺序从右往左 int num = a + b + c;
  2. 赋值运算符的左边只能是变量，右边可以是变量、表达式、常量值
     int num = 20;  int num2 = 78 * 34 - 10;  int num3 = a;
  3. 复合赋值运算符等价于下面的效果
     比如：a+=3;等价于a=a+3; 其他类推
  4. 复合赋值运算符会进行类型转换。
     byte b = 2; b+=3; //等价于 b = (byte)(b + 3);



### 三元运算符 ternary operator

- 条件表达式 ? 表达式1 : 表达式2;

- 运算规则：

  如果条件表达式为true，运算后的结果是表达式1；

  如果条件表达式为false，运算后的结果是表达式2。

- 细节：

  1. 表达式1 和 表达式2 要为可以赋给接收变量的类型（或可以自动转换或强制转换）
  2. 三元运算符可以转成 if--else 语句



### 进制转换

- 四种进制介绍

  对于整数，有四种表示方式：
  二进制：0, 1 ，满 2 进 1。以 0b 或 0B 开头表示。
  十进制：0 - 9 ，满 10 进 1。
  八进制：0 - 7 ，满 8 进 1。以数字 0 开头表示。
  十六进制：0 - 9 及 A(10) - F(15)，满 16 进 1。 以 0x 或 0X 开头表示。此处的 A - F 不区分大小写。

- 二进制转换成十进制

  规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 2 的 (位数-1) 次方，然后求和。
  案例：将 0b1011 转成十进制的数

- 八进制转换成十进制

  规则：从最低位(右边)开始，将每个位上的数提取出来，乘以 8 的 (位数-1) 次方，然后求和。
  案例：将 0234 转成十进制的数 

- 十六进制转换成十进制

  规则：从最低位(右边)开始，将每个位上的数提取出来，乘以16 的 (位数-1) 次方，然后求和。
  案例：请将0x23A 转成十进制的数
  0x23A = 10 * 16^0 + 3 * 16 ^ 1 + 2 * 16^2 = 10 + 48 + 512 = 570

- 十进制转换成二进制

  规则：将该数不断除以 2，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的二进制。
  案例：将 34 转成二进制 => 0B00100010

- 十进制转换成八进制

  规则：将该数不断除以 8，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的八进制。
  案例：将 131 转成八进制 => 0203

- 十进制转换成十六进制

  规则：将该数不断除以 16，直到商为 0 为止，然后将每步得到的余数倒过来，就是对应的十六进制。
  案例：将 237 转成十六进制 => 0xED

- 二进制转换成八进制

  规则：从低位开始,将二进制数每三位一组，转成对应的八进制数即可。
  案例：将 0b11010101 转成八进制   0b11(3)010(2)101(5) => 0325

- 二进制转换成十六进制

  规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。
  案例：将 0b11010101 转成十六进制   0b1101(D)0101(5) = 0xD5

- 八进制转换成二进制

  规则：将八进制数每 1 位，转成对应的一个 3 位的二进制数即可。
  案例：将 0237 转成二进制   02(010)3(011)7(111) = 0b10011111

- 十六进制转换成二进制

  规则：将十六进制数每 1 位，转成对应的 4 位的一个二进制数即可。
  案例：将 0x23B 转成二进制   0x2(0010)3(0011)B(1011) = 0b001000111011



### 位运算符 bit operator

|         位运算符         |  语法  | 运算规则                                     |
| :----------------------: | :----: | :------------------------------------------- |
|         按位与 &         | a & b  | 两位全为 1，结果为 1，否则为 0               |
|        按位或 \|         | a \| b | 两位有一个为 1，结果为 1，否则为 0           |
|        按位异或 ^        | a ^ b  | 两位一个为 0，一个为 1，结果为 1，否则为 0   |
|        按位取反 ~        |  ~ a   | 0 -> 1， 1 -> 0                              |
|       算术右移 >>        | a >> b | 低位溢出，符号位不变，并用符号位补溢出的高位 |
|       算术左移 <<        | a << b | 符号位不变，低位补 0                         |
| >>> 逻辑右移(无符号右移) |        | 低位溢出，高位补 0                           |

```java
int a = 1 >> 2; //1 => 00000001 => 00000000 本质 1 / 2 / 2 =0
int b = 1 << 2; //1 => 00000001 => 00000100 本质 1 * 2 * 2 = 4

int c = 4 << 3; // 4 * 2 * 2 * 2 = 32
int d = 15 >> 2; // 15 / 2 / 2 = 3
```



### 运算符优先级

> 优先级就是表达式运算中的运算顺序。

|               | 运算符                        |
| ------------- | ----------------------------- |
|               | ()   {}   .   ,   ;           |
| R--->L   单目 | ++   --   ~   !   (data type) |
| L--->R   算术 | *   /   %                     |
| L--->R        | +   -                         |
| L--->R   位移 | <<   >>   >>>                 |
| L--->R   比较 | <   >   <=   >=   instanceof  |
| L--->R        | ==   !=                       |
| L--->R   逻辑 | &                             |
| L--->R        | ^                             |
| L--->R        | \|                            |
| L--->R        | &&                            |
| L--->R        | \|\|                          |
| L--->R   三元 | ?   :                         |
| R--->L   赋值 | =   *=   /=   %=              |
|               | +=   -=   <<=   >>=           |
|               | >>>=   &=   ^=   \|=          |



### 标识符的命名规则和规范

- 标识符概念
- 标识符的命名规则（必须遵守）
- 标识符的命名规范（更加专业）
- 关键字
- 保留字



## Chapter05 程序控制结构

### 顺序控制



### 分支控制

- if - else

  - 单分支 if
  - 双分支 if - else
  - 多分支 if - else if - .... - else
  - 嵌套分支

- switch

  ```java
  switch(表达式) {
      case 常量1:
          语句块1;
          break;
      case 常量2:
          语句块2;
          break;
      ...
      case 常量n:
          语句块n;
          break;
      default:
          default语句块;
          break;
  }
  
  //细节1
  //表达式数据类型，应和 case 后的常量类型一致，
  //或者是可以自动转成可以相互比较的类型，比如输入的是字符，而常量是 int
  
  //细节2
  //switch(表达式)中表达式的返回值必须是：
  //(byte,short,int,char,enum,String)
  
  //细节3
  //case子句中的值必须是常量(1,'a')或者是常量表达式，而不能是变量
  
  //细节4
  //default子句是可选的，当没有匹配的case时，执行default
  //如果没有default 子句，有没有匹配任何常量，则没有输出
  
  //细节5
  //break语句用来在执行完一个case分支后使程序跳出switch语句块；
  //如果没有写break，程序会顺序执行到switch结尾，除非执行到break
  ```

- switch 和 if 的比较

  1. 如果判断的具体数值不多，而且符合 byte、short 、int、char、enum、String 这 6 种类型。虽然两个语句都可以使用，建议使用swtich 语句。
  2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广。



### 循环控制

> 循环四要素：1.循环变量初始化  2.循环条件  3.循环体  4.循环变量迭代

- for 

  ```java
  for(循环变量初始化;循环条件;循环变量迭代) {
      循环体;
  }
  
  for(int i = 1; i <= 10 ; i++) {    
  	System.out.println("hello" + i);
  }
  
  //1.循环条件是返回一个布尔值的表达式
  //2.for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。
  int i = 1;
  for( ; i <= 10 ; ) {    
  	System.out.println("hello" + i);
  	i++;
  }
  //3.循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开。
  //  循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开。
  int count = 3;
  for(int i = 0, j = 0; i < count; i++, j += 2) {
  	System.out.println("i=" + i + " j=" + j);
  }
  //4.无限循环，死循环
  int j = 1;
  for(;;) { 
  	System.out.println("ok~" + (j++));
  }
  
  ```

  

- while

  ```java
  循环变量初始化;
  while(循环条件) {
      循环体;
      循环变量迭代;
  }
  
  int i = 1;
  while(i <= 10) {
      System.out.println("hello" + i);
      i++;
  }
  
  ```

  

- do - while

  ```java
  循环变量初始化;
  do {
      循环体;
      循环变量迭代;
  } while(循环条件);
  
  //先执行，再判断，也就是说，一定会至少执行一次。
  ```

  

- 多重循环

> 将一个循环放在另一个循环体内，就形成了嵌套循环。
>
> 其中，for , while , do…while 均可以作为外层循环和内层循环。
>
> 【建议一般使用 2 层，最多不要超过3 层，否则代码的可读性很差】



### break

> break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环 [for , while , do-while] 中。



### continue

> continue 语句用于结束本次循环，继续执行下一次循环。



### return

> return 使用在方法，表示跳出所在的方法。如果 return 写在 main 方法，退出程序。



## Chapter06 数组、排序和查找

### 数组 array

> 数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。
> 即：数(数据)组(一组)就是一组数据。

- 数组的使用

  ```java
  //1.动态初始化
  //直接定义
  int[] arr = new int[5];//创建一个数组，数组名arr，存放5个int
  
  //先声明，再定义
  int[] arr;
  arr = new int[10];//分配内存空间
  
  //2.静态初始化
  int[] arr = {1,2,3,4,5};
  
  //访问数组元素
  arr[index];
  //数组的长度
  arr.length
  ```

- 数组使用注意事项和细节

  1) 数组是多个相同类型数据的组合，实现对这些数据的统一管理。

  2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。

  3) 数组创建后，如果没有赋值，有默认值

  ​	int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null.

  4) 使用数组的步骤 1. 声明数组并开辟空间 2. 给数组各个元素赋值 3. 使用数组

  5) 数组的下标是从0 开始的。

  6) 数组下标必须在指定范围内使用，否则报：下标越界异常。

  7) 数组属引用类型，数组型数据是对象(object)。

- 数组赋值机制 array assign

  引用传递（地址拷贝），数据空间是共享的

- 数组拷贝 array copy

  内容复制，数据空间是独立的

- 数组反转 array reverse

- 数组扩容 array add

- 数组缩减 array reduce



### 排序

- 冒泡排序 bubble sort

### 查找

- 顺序查找 sequence search
- 二分查找

### 二维数组

```java
//1.动态初始化
//直接定义
int[][] arr = new int[2][3];

//先声明，再定义(开辟空间)
int[][] arr;
arr = new int[2][3];

//列数不确定
int[][] arr = new int[2][];
arr[0] = new int[3];
arr[1] = new int[3];

//2.静态初始化
int[][] arr = {{1,2,3},{4,5},{6}};

```

