# Java SE 02



## Chapter07 面向对象编程(初级)

### 类与对象

- 类 class：自定义的数据类型

  - 属性 properties
  - 方法 method

- 对象 object：一个具体的实例

- 类和对象的内存分配机制

  - Java 内存的结构

    1. 栈： 存放基本类型的数据(局部变量)
    2. 堆： 存放引用类型的数据(对象、 数组)
    3. 方法区：常量池(常量，比如字符串)， 类加载信息

  - Java 创建对象的流程

    ```java
    Person p = new Person();
    p.name = "jack";
    p.age = 10;
    
    class Person {
        String name;
        int age;
    }
    
    /*
    ```

1. 先加载 Person 类信息(属性和方法信息, 只会加载一次)

   2. 在堆中分配空间，进行默认初始化
   3. 把地址赋给 p , p 就指向对象
   4. 进行指定初始化， 比如 p.name = "jack"; p.age = 10;
      */

   ```
   
   ```



### 属性和方法

```java
class 类名 {
    //属性的定义
    访问修饰符  属性类型  属性名;
    
    //方法的定义
    访问修饰符 返回数据类型 方法名（形参列表） {
        //方法体
		语句；
		return 返回值;
	}
}

```

- 属性

  1. 概念或叫法： 成员变量 = 属性 = field(字段)

  2. 属性的定义语法同变量，示例：访问修饰符  属性类型  属性名;

     访问修饰符： 控制属性的访问范围。有 4 种访问修饰符 public,  proctected,  默认, private

  3. 属性的定义类型可以为任意类型，包含基本类型或引用类型

  4. 属性如果不赋值，有默认值，规则和数组一致。

     int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null.

- 方法的调用机制

- 方法的好处

  1. 提高代码的复用性
  2. 可以将实现的细节封装起来，然后供其他用户来调用即可

- 方法的使用细节

  - 访问修饰符

    作用是控制方法使用的范围。如果不写，默认访问。[有四种: public, protected, 默认, private]

  - 返回数据类型

    1. 一个方法最多有一个返回值。[如何返回多个结果? 返回数组]
    2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)
    3. 如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的值类型一致或兼容
    4. 如果方法是 void，则方法体中可以没有 return 语句，或者只写 return ;

  - 方法名

    遵循驼峰命名法，最好见名知义，表达出该功能的意思。比如得到两个数的和getSum，开发中按照规范

  - 形参列表

    1. 一个方法可以有 0 个参数，也可以有多个参数，中间用逗号隔开，比如 getSum(int n1, int n2)

    2. 参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(int[] map)

    3. 调用带参数的方法时，一定对应着形参列表传入相同类型或兼容类型的参数。

    4. 方法定义时的参数称为形式参数，简称形参；方法调用时的传入参数称为实际参数，简称实参。

       实参和形参的类型要一致或兼容，个数、顺序必须一致。

  - 方法体

    里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用。

    但里面不能再定义方法，即：方法不能嵌套定义。

  - 方法调用

    1. 同一个类中的方法调用：直接调用即可。
    2. 跨类中的方法调用，A 类方法调用 B 类方法，需要通过对象名调用，即：先创建对象，再调用方法。



### 方法传参机制 parameter

- 基本数据类型的传参机制

  基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参。

- 引用数据类型的传参机制

  引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参。



### 方法递归调用 recursion

> 递归就是方法自己调用自己，每次调用时传入不同的变量。
>
> 递归有助于编程者解决复杂问题，同时可以让代码变得简洁。

- 递归解决什么问题
  - 阶乘
  - 斐波那契数列
  - 迷宫
  - 汉诺塔
  - 八皇后



### 方法重载 overload

> java 中允许同一个类中，多个同名方法的存在，但要求形参列表不一致。

- 细节
  1. 方法名：必须相同
  2. 形参列表：必须不同（参数类型或个数或顺序，至少有一样不同，参数名无要求）
  3. 返回类型：无要求



### 可变参数 variable parameter

> java 允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。可以通过可变参数实现。
>
> 访问修饰符  返回类型  方法名(数据类型... 形参名) {
>
> }

- 细节
  1. 可变参数的实参可以为 0 个或任意多个
  2. 可变参数的实参可以为数组
  3. 可变参数的本质就是数组
  4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
  5. 一个形参列表中只能出现一个可变参数



### 变量作用域 variable scope

- 基本使用

  1. 在 Java 编程中，主要的变量就是属性(成员变量)和局部变量。

  2. 局部变量一般是指在成员方法中定义的变量。

  3. Java 中作用域的分类

     - 全局变量：也就是属性，作用域为整个类体
     - 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中。

  4. 全局变量(属性)可以不赋值，直接使用，因为有默认值。

     局部变量必须赋值后，才能使用，因为没有默认值。

- 细节

  1. 属性和局部变量可以重名，访问时遵循就近原则
  2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
  3. 生命周期不同
     - 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。
     - 局部变量生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中生效。
  4. 作用域范围不同
     - 全局变量/属性：可以被本类使用，或其他类使用(通过对象调用)。
     - 局部变量：只能在本类中对应的方法中使用。
  5. 修饰符不同
     - 全局变量/属性 可以加修饰符(public protected private..)。
     - 局部变量不能加修饰符。



### 构造器 constructor

> 构造方法又叫构造器，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。
>
> [修饰符]  方法名  (形参列表) {
> 		方法体;
> }

- 细节
  1. 构造器的修饰符可以默认， 也可以是 public, protected, private
  2. 构造器没有返回值，也不能写 void
  3. 方法名和类名必须相同
  4. 形参列表和成员方法一样的规则
  5. 在创建对象时，系统会自动的调用该类的构造器，完成对象的属性初始化。
  6. 一个类可以定义多个不同的构造器，即构造器重载
  7. 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)。
  8. 一旦定义了自己的构造器，默认的构造器就覆盖了，就不能再使用默认的构造器，除非显式的定义一下。



### this关键字

> Java 虚拟机会给每个对象分配 this，代表当前对象。
>
> 哪个对象调用，this 就代表哪个对象。

- 细节

  1. this 关键字可以用来访问本类的属性、方法、构造器

  2. this 用于区分当前类的属性和局部变量

  3. 访问成员方法的语法：this.方法名(参数列表);

  4. 访问构造器的语法：this(参数列表); 

     注意只能在构造器中使用(即只能在构造器中访问另外一个构造器)，且必须放在第一条语句。

  5. this 不能在类定义的外部使用，只能在类定义的方法中使用。



### 对象创建的流程分析

```java
//类Person
class Person {
    //成员变量
    String name;
    int age = 20;
    
    //构造器
    Person(String pName, int pAge) {
        name = pName;
        age = pAge;  
    }
    
    //成员方法
    
}

Person p = new Person("jack", 18);

/*
对象创建的流程分析
1.加载Person类信息(Person.class)，只会加载一次
2.在堆中分配空间(地址)
3.完成对象初始化
  3.1 默认初始化 name=null, age=0 
  3.2 显示初始化 name=null, age=20
  3.3 构造器的初始化 name=jack, age=18
4.对象在堆中的地址，返回给p (p是对象名，也可称为对象的引用)
*/

```



## Chapter08 面向对象编程(中级)

### IntelliJ IDEA

- IDEA 常用快捷键

  1. 删除当前行, 默认是 ctrl + Y, 自己配置 ctrl + d
  2. 复制当前行, 自己配置 ctrl + alt + 向下光标
  3. 补全代码 alt + /
  4. 添加注释和取消注释 ctrl + / 【第一次是添加注释，第二次是取消注释】
  5. 导入该行需要的类先配置 auto import , 然后使用 alt+enter 即可
  6. 快速格式化代码 ctrl + alt + L
  7. 快速运行程序自己定义 alt + R
  8. 生成构造器等 alt + insert [提高开发效率]
  9. 查看一个类的层级关系 ctrl + H [学习继承后，非常有用]
  10. 将光标放在一个方法上，输入 ctrl + B , 可以定位到方法[学继承后，非常有用]
  11. 自动的分配变量名, 通过在后面加 .var

- 模板快捷键

  file -> settings -> editor -> Live templates -> 查看有哪些模板快捷键/可以自己增加模板。



### 包 package

- 包的三大作用

  1. 区分相同名字的类
  2. 当类很多时，可以很好的管理类
  3. 控制访问范围

- 包基本语法

  package  com.xxxx;

  package 关键字，表示打包。com.xxxx 表示包名。

- 包的本质/原理

  创建不同的文件夹/目录来保存类文件。

- 包命名

  - 规则

    只能包含 数字、字母、下划线、小圆点，但不能用数字开头，不能是关键字或保留字。

  - 规范

    小写字母 + 小圆点

    com.公司名.项目名.业务模块名

    举例：com.sina.crm.user //用户模块    com.sina.crm.order //订单模块    com.sina.crm.utils //工具类

- 常用的包

  - java.lang.*  //基本包，默认引入
  - java.util.*  //系统提供的工具包，工具类
  - java.net.*  //网络包，网络开发
  - java.awt.*  //是做 java 的界面开发，GUI

- 细节

  1. package 的作用是声明当前类所在的包，需要放在类(或者文件)的最上面，

     一个类中最多只有一句 package

  2. import 指令放在 package 的下面，在类定义前面，可以有多句且没有顺序要求。



### 访问修饰符 modifier

> java 提供四种访问控制修饰符号，用于控制方法和属性的访问权限（范围）。

- 4 种访问修饰符的访问范围

  | 访问级别 | 访问控制修饰符 | 本类 | 同包 | 子类 | 不同包 |
  | -------- | -------------- | :--: | :--: | :--: | :----: |
  | 公开     | public         |  √   |  √   |  √   |   √    |
  | 受保护   | protected      |  √   |  √   |  √   |   ×    |
  | 默认     | 没有修饰符     |  √   |  √   |  ×   |   ×    |
  | 私有     | private        |  √   |  ×   |  ×   |   ×    |

- 细节

  1. 访问修饰符可以用来修饰 类中的属性、方法，以及类。
  2. 只有默认和 public 才能修饰类。



### OOP 三大特征

> 面向对象编程有三大特征：封装、继承和多态。

- 封装

  - 概念

    封装(encapsulation)就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。

  - 好处

    1. 隐藏实现细节：方法 <-- 调用(传入参数...)
    2. 可以对数据进行校验，保证安全合理

  - 实现步骤（三步）

    1. 将属性进行私有化 private 【外部不能直接修改属性】
    2. 提供一个公共的 (public) set 方法，用于对属性判断并赋值。
    3. 提供一个公共的 (public) get 方法，用于获取属性的值。

    ```java
    class A {
        private 数据类型 属性;
        
        public A() {//无参构造器
            
        }
        
        public A(类型 参数名) {//有参构造器
            //将构造器和setXxx结合，让数据校验生效
            this.setXxx(参数名);
        }
        
        public void setXxx(类型 参数名) {//Xxx 表示某个属性
            //加入数据校验的业务逻辑
            属性 = 参数名;
        }
    
        public 数据类型 getXxx() {
            //加入权限判断
            return xx;
        }
    }
    
    ```

    

- 继承

  - 概念

    继承(extends)可以解决代码复用，让编程更加靠近人类思维。当多个类存在相同的属性(变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来声明继承父类即可。

  - 基本语法

    ```java
    class 子类 extends 父类 {
        
    }
    /*
    1.子类就会自动拥有父类定义的属性和方法
    2.父类又叫 超类、基类
    3.子类又叫 派生类
    */
    ```

  - 好处

    1. 代码的复用性提高了
    2. 代码的扩展性和维护性提高了

  - 细节

    1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问， 但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问。
    2. 子类必须调用父类的构造器， 完成父类的初始化
    3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的每个构造器中用 super() 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。
    4. 如果希望指定去调用父类的某个构造器，则显式的调用一下: super(参数列表)
    5. super() 在使用时，必须放在构造器第一行(super() 只能在构造器中使用)
    6. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
    7. java 所有类都是 Object 类的子类，Object 是所有类的基类
    8. 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object 类(顶级父类)
    9. 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制。
       思考：如何让 A 类继承 B 类和 C 类？ 【A 继承 B， B 继承 C】
    10. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系。

  - 继承的本质

    当子类继承父类，创建子类对象时，内存中到底发生了什么？当子类对象创建好后，建立查找的关系。

    ```java
    /*
    访问属性或调用方法，要按照查找关系来返回信息
    (1) 首先看子类是否有该属性/方法
    (2) 如果子类有这个属性，并且可以访问，则返回信息
    (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息)
    (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到Object...
    
    // 如果查找属性或方法的过程中，找到了，但是不能访问， 则报错, cannot access
    // 如果查找属性或方法的过程中，没有找到，则提示方法不存在
    */
    ```

    

- 多态

  - 概念

    方法或对象具有多种形态，多态 (polymorphic) 是建立在封装和继承基础之上的。

  - 多态的具体体现

    - 方法的多态

      重写和重载就体现多态。

    - 对象的多态

      1. 一个对象的编译类型和运行类型可以不一致
      2. 编译类型在定义对象时，就确定了，不能改变
      3. 运行类型是可以变化的
      4. 编译类型看定义时 = 号的左边，运行类型看 = 号的右边

  - 细节

    - 多态的前提：两个对象(类)存在继承关系
    - 多态的向上转型
      1. 本质：父类的引用指向了子类的对象
      2. 语法：父类类型  引用名  =  new  子类类型();
      3. 特点：
         - 编译类型看左边，运行类型看右边。
         - 可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员。因为在编译阶段，能调用哪些成员,是由编译类型来决定的。
         - 最终运行效果看子类(运行类型)的具体实现，即调用方法时，按照从子类(运行类型)开始查找方法，然后调用，规则和方法调用规则一致。
    - 多态的向下转型
      1. 语法：子类类型  引用名  =   (子类类型)  父类引用;
      2. 只能强转父类的引用，不能强转父类的对象
      3. 要求父类的引用必须指向的是当前目标类型的对象
      4. 当向下转型后，可以调用子类类型中所有的成员
    - 属性没有重写之说，属性的值看编译类型。
    - instanceof 比较操作符，用于判断对象的**运行类型**是否为 XX类型 或 XX类型的子类型。

  - java 的动态绑定机制

    1. 当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定。
    2. 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用。

  - 多态的应用

    - 多态数组

      数组的定义类型为父类类型，里面保存的实际元素类型为子类类型。

    - 多态参数

      方法定义的形参类型为父类类型，实参类型允许为子类类型。



### Super 关键字

> super 代表父类的引用，用于访问父类的属性、方法、构造器。

- 基本语法

  ```java
  //1.访问父类的属性，但不能访问父类的 private 属性
  super.属性名;
  //2.访问父类的方法，但不能访问父类的 private 方法
  super.方法名(参数列表);
  //3.访问父类的构造器。只能放在构造器的第一句，只能出现一句。
  super(参数列表);
  ```

- 细节

  1. 调用父类的构造器的好处：分工明确，父类的属性由父类初始化，子类的属性由子类初始化。

  2. 当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过 super。

     如果没有重名，使用 super、this、直接访问 是一样的效果。

  3. super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super 去访问爷爷类的成员；如果多个基类(上级类)中都有同名的成员，使用super 访问遵循就近原则。A->B->C

     当然也需要遵守访问权限的相关规则。

- super 和 this 的比较

  |      | 区别点     | this                                                       | super                                          |
  | ---- | ---------- | ---------------------------------------------------------- | ---------------------------------------------- |
  | 1    | 访问属性   | 访问本类中的属性，如果本类没有此属性<br />则从父类继续查找 | 从父类开始查找属性                             |
  | 2    | 调用方法   | 访问本类中的方法，如果本类没有此方法<br />则从父类继续查找 | 从父类开始查找方法                             |
  | 3    | 调用构造器 | 调用本类构造器，<br />必须放在构造器的首行                 | 调用父类构造器，<br />必须放在子类构造器的首行 |
  | 4    | 特殊       | 表示当前对象                                               | 子类中访问父类对象                             |

  

### 方法重写 override

> 方法覆盖（重写）就是：子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么就说子类的这个方法覆盖了父类的那个方法。

- 方法重写需要满足下面的条件

  1. 子类方法的形参列表、方法名称，要和父类方法的形参列表、方法名称完全一样。

  2. 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类。

     比如父类返回类型是Object，子类方法返回类型是String

  3. 子类方法不能缩小父类方法的访问权限。public > protected > 默认 > private

- 方法的重写和重载（对比）

  | 名称           | 发生范围 | 方法名   | 形参列表                             | 返回类型                                                     | 修饰符                                   |
  | :------------- | -------- | -------- | ------------------------------------ | ------------------------------------------------------------ | ---------------------------------------- |
  | 重载(overload) | 本类     | 必须一样 | 类型、个数、顺序<br />至少有一个不同 | 无要求                                                       | 无要求                                   |
  | 重写(override) | 父子类   | 必须一样 | 相同                                 | 子类方法返回类型和父类<br />方法返回类型一样，或者是其子类。 | 子类方法不能缩小<br />父类方法的访问权限 |

  

### Object 类详解

- equals() 方法

  - == 和 equals 的对比

    1. == 是一个比较运算符。既可以判断基本类型，又可以判断引用类型。

       基本类型，判断值是否相等；引用类型，判断地址是否相等，即判断是不是同一个对象。

    2. equals 是 Object 类中的方法，只能判断引用类型。

       默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如 Integer, String.

  - 如何重写 equals 方法

- hashCode() 方法

  1. 提高具有哈希结构的容器的效率。
  2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的。
  3. 两个引用，如果指向的是不同对象，则哈希值是不一样的。
  4. 哈希值主要根据地址号来的， 不能完全将哈希值等价于地址。
  5. 如果需要的话，在集合中 hashCode() 也会重写。

- toString() 方法

  1. 默认返回：全类名(包名+类名) + @ + 哈希值的十六进制

     子类往往重写 toString 方法，用于返回对象的属性信息。

  2. 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 方法。

  3. 当直接输出一个对象时， toString 方法会被默认的调用。

- finalize() 方法

  1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作。

  2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回

     收机制来销毁该对象，在销毁该对象前，会先调用 finalize 方法。

  3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法)，也可以通过 System.gc() 主动触发垃圾回收

     机制。

  4. 在实际开发中，几乎不会运用 finalize() 方法。



### 断点调试 breakpoint debug

- 断点调试的快捷键

  F7(跳入)	F8(跳过)	shift+F8(跳出)	F9(resume, 执行到下一个断点)

  F7：跳入方法内 

  F8：逐行执行代码

  shift+F8：跳出方法





## Chapter09 面向对象编程(高级)

### 类变量和类方法 static

- 类变量

  - 概念

    类变量也叫静态变量/静态属性，是该类的所有对象共享的变量。任何一个该类的对象去访问它时，取到的都是相同的值；同样任何一个该类的对象去修改它时，修改的也是同一个变量。

  - 定义类变量

    访问修饰符  static  数据类型  变量名;【推荐使用】

     static 访问修饰符  数据类型  变量名;

  - 访问类变量

    类名.类变量名【推荐使用】

    对象名.类变量名

  - 类变量的使用场景

    当我们需要让某个类的所有对象都共享一个变量时，就可以使用类变量。

  - 细节

    1. 类变量与实例变量的区别：类变量是该类的所有对象共享的，实例变量是每个对象独享的。
    2. 实例变量不能通过 [类名.变量名] 方式访问。
    3. 类变量在类加载时就初始化了，即使没有创建对象，只要类加载了，就可以使用类变量了。
    4. 类变量的生命周期是随类的加载开始，随着类消亡而销毁。

- 类方法

  - 概念

    类方法也叫静态方法。

  - 定义类方法

    访问修饰符  static  数据返回类型  方法名() { };【推荐使用】

     static 访问修饰符  数据返回类型  方法名() { };

  - 调用类方法

    类名.类方法名【推荐使用】

    对象名.类方法名

  - 类方法的使用场景

    1. 当方法中不涉及到任何和对象相关的成员。

       比如工具类中的方法，Math 类、Arrays 类、Collections 集合类

    2. 如果我们希望不创建对象实例，也可以调用某个方法(即当做工具来使用)，或者是将一些通用的方法，设计成静态方法。

  - 细节

    1. 类方法和普通方法(成员方法)都是随着类的加载而加载，将结构信息存储在方法区。

       类方法中无 this 的参数，成员方法中隐含着 this 的参数。

    2. 类方法中不允许使用和对象有关的关键字，比如 this 和 super。成员方法可以。

    3. 静态方法只能访问静态成员。

       非静态方法可以访问静态成员和非静态成员。(必须遵守访问权限)



### main 方法

- 语法说明：public  static  void  main(String[]  args) { }

  1. main 方法是虚拟机调用

  2. java虚拟机需要调用类的 main() 方法，所以该方法的访问权限必须是 public

  3. java 虚拟机在执行 main() 方法时不必创建对象，所以该方法必须是 static

  4. 该方法接收 String 类型的数组参数，该数组中保存执行 java 命令时传递给所运行的类的参数。

     java  运行的类名  参数1 参数2  参数3 ...

  5. 在 IDEA 如何传递参数

- 特别说明

  1. 在 main() 方法中，可以直接调用 main() 方法所在类的静态成员。
  2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。



### 代码块 code block

- 概念

  代码块又称为**初始化块**，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过 { } 包围起来。

  但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

- 基本语法

  ```java
  [修饰符] {
      代码
  };
  /*
  1.修饰符可选，要写的话，也只能写 static
  2.代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块。
  3.逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）。
  4.;号可以写上，也可以省略。
  */
  ```

- 代码块的好处

  1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作。
  2. 应用场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性。

- 细节

  1. static 代码块是在 **类加载** 时执行，只会执行一次。

  2. 普通代码块是在 **创建对象实例** 时执行，创建一次，执行一次。

  3. 类加载的 3 种情况：

     1. 创建对象实例时(new)
     2. 创建子类对象实例，父类也会被加载
     3. 使用类的静态成员时

  4. 创建一个对象时，在一个类 调用顺序是：（重点、难点）

     1. 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态属性初始化，则按它们定义的顺序调用）
     2. 调用普通代码块和普通属性初始化（...）
     3. 调用构造方法。

  5. 构造器的最前面隐含了 super() 和 调用普通代码块。静态代码块、静态属性初始化，在类加载时就执行完毕，因此是优先于 构造器和普通代码块执行的。

     ```java
     class A {
         public A() {//构造器
             //这里有隐藏的执行要求
             //1. super();
             //2. 调用普通代码块和普通属性初始化
             System.out.println("A()构造器被调用");//3.构造方法
         }
     }
     
     /*
     创建一个子类对象时:
     (1) 进行类的加载
     	1.1 先加载父类：父类的静态代码块、静态属性初始化
     	1.2 再加载子类：子类的静态代码块、静态属性初始化
     (2) 创建子类对象
     	从子类的构造器开始
     	2.1 super();
       		2.1.1 super();
       		2.1.2 父类的普通代码块、普通属性初始化
       		2.1.3 父类的构造方法
     	2.2 子类的普通代码块和普通属性初始化
     	2.3 子类的构造方法
     */
     ```

  6. 创建一个子类对象时（继承关系），静态代码块、静态属性初始化、普通代码块、普通属性初始化、构造方法的调用顺序如下：

     1. 父类的静态代码块、静态属性初始化（优先级一样，按定义顺序执行）
     2. 子类的静态代码块、静态属性初始化（优先级一样，按定义顺序执行）
     3. 父类的普通代码块、普通属性初始化（优先级一样，按定义顺序执行）
     4. 父类的构造方法
     5. 子类的普通代码块、普通属性初始化（优先级一样，按定义顺序执行）
     6. 子类的构造方法

  7. 静态代码块，只能调用静态成员。普通代码块，可以调用任意成员。

  

### 单例设计模式

> 设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、解决问题的思考方式。

- 单例模式

  1. 类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。
  2. 单例模式的两种实现方式：(1) 饿汉式  (2) 懒汉式

- 单例模式 - 饿汉式 

  1. 将构造器私有化（防止在外部直接 new ）
  2. 在类的内部直接创建对象（该对象是 static）
  3. 向外提供一个 public 的 static 方法，返回对象

- 单例模式 - 懒汉式 

  1. 将构造器私有化
  2. 定义一个 static 属性对象
  3. 提供一个 public 的 static 方法，可以返回对象
  4. 只有当用户调用 getInstance() 时，才会返回对象。后面再次调用时，会返回上次创建的对象，从而保证了单例。

- 饿汉式 VS 懒汉式

  1. 饿汉式：在类加载时就创建对象实例，可能存在资源浪费问题。
  2. 懒汉式：在使用时才创建对象实例，存在线程安全问题。

  

### final 关键字

final 可以修饰 类、属性、方法、局部变量。

- 会使用到 final 的情况

  1. 不希望类被继承
  2. 不希望父类的某个方法被子类 override 
  3. 不希望类的某个属性的值被修改
  4. 不希望某个局部变量被修改

- 细节

  1. final 修饰的属性又叫常量，一般用 XX_XX_XX 来命名。

  2. final 修饰的属性在定义时必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：

     (1) 定义时  (2) 在构造器中  (3) 在代码块中

  3. 如果 final 修饰的属性是静态的，则初始化的位置只能是：

     (1) 定义时  (2) 在静态代码块中，不能在构造器中赋值。

  4. final 类不能继承，但是可以实例化对象。

  5. 如果类不是 final 类，但是含有 final 方法，则该方法虽然不能重写，但是可以被继承。

  6. 如果一个类已经是 final 类了，就没有必要再将方法修饰成 final 方法

  7. final 不能修饰构造方法(即构造器)

  8. final 和 static 往往搭配使用，效率更高，因为不会导致类加载。底层编译器做了优化处理。

  9. 包装类(Integer, Double, Float, Boolean)、String 也是 final 类，不能被继承。



### 抽象类 abstract

> 当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。一般来说，抽象类会被继承，由其子类来实现抽象方法。

```java
访问修饰符 abstract 类名 {
    
    访问修饰符 abstract 返回类型 方法名(形参列表);//没有方法体
}

```

- 抽象类的作用

  抽象类的价值在于设计，是设计者设计好后，让子类继承并实现抽象方法。

  抽象类在框架和设计模式使用较多。

- 细节

  1. 抽象类不能被实例化。
  2. 抽象类不一定要包含 abstract 方法。也就是说，抽象类可以没有 abstract 方法，还可以有实现的方法。
  3. 一旦类包含了 abstract 方法,则这个类必须声明为 abstract
  4. abstract 只能修饰类和方法，不能修饰属性和其它的。
  5. 抽象类的本质还是类，所以可以有类的各种成员。
  6. 抽象方法不能有主体，即不能实现。
  7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为 abstract 类。
  8. 抽象方法不能使用 private、final、static 来修饰，因为这些关键字都是和重写相违背的。

- 抽象类最佳实践 -- 模板设计模式

  - 基本介绍

    抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

  - 模板设计模式能解决的问题

    1. 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
    2. 编写一个抽象父类，父类提供了多个子类的通用方法 ，并把一个或多个方法留给其子类实现，就是一种模板模式。



### 接口 interface

> 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。

```java
interface 接口名 {
    //属性
    //方法（1.抽象方法 2.默认实现方法 default 3.静态方法 static）
}

class 类名 implements 接口名 {
    //自己属性
    //自己方法
    //必须实现的接口的抽象方法
}
```

- 细节

  1. 接口不能被实例化

  2. 接口中所有的方法是 public 方法，接口中抽象方法，可以不用 abstract 修饰

  3. 一个普通类实现接口，就必须将该接口的所有方法都实现，可以使用 alt+enter 快捷键

  4. 抽象类去实现接口时，可以不实现接口的抽象方法

  5. 一个类同时可以实现多个接口

  6. 接口中的属性，只能是 final 的，而且是 public  static  final 修饰符。

     int a = 10; //等价 public static final int a = 10; (必须初始化)

  7. 接口中属性的访问形式：接口名.属性名

  8. 接口不能继承其它的类，但是可以继承多个别的接口。interface A extends B, C { }

  9. 接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的。

- 实现接口 VS 继承类

  > 当子类继承了父类，就自动的拥有父类的功能。
  >
  > 如果子类需要扩展功能，可以通过实现接口的方式扩展。
  >
  > 可以理解为 实现接口是对 java 单继承机制的一种补充。

  1. 接口和继承解决的问题不同

     继承的价值在于：解决代码的复用性和可维护性。

     接口的价值在于：设计，设计好各种规范(方法)，让其它类去实现这些方法。

  2. 接口比继承更加灵活

     继承是满足 is - a 的关系，而接口只需满足 like - a 的关系。

  3. 接口在一定程度上实现代码解耦 [即: 接口规范性 + 动态绑定机制]

- 接口的多态特性

  - 多态参数

    接口类型的变量（接口引用），可以指向实现了接口的类的对象实例。

  - 多态数组

  - 接口多态传递



### 内部类 inner class

> 一个类的内部又完整地嵌套了另一个类结构。被嵌套的类称为内部类 (inner class)，嵌套其他类的类称为外部类 (outer class)。内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。
>
> 类的五大成员：属性、方法、构造器、代码块、内部类

```java
class Outer {//外部类
    class Inner {//内部类
        
    }
}

class Other {//外部其他类
    
}
```

- 分类

  - 定义在外部类的局部位置 (方法/代码块)：

    (1) 局部内部类 (有类名)

    (2) 匿名内部类 (没有类名) 【重要 ! ! !】

  - 定义在外部类的成员位置：

    (1) 成员内部类 (没有 static 修饰)

    (2) 静态内部类 (有 static 修饰)

- 局部内部类

  1. 可以直接访问外部类的所有成员，包含私有的。

  2. 不能添加访问修饰符，但是可以使用 final 修饰。因为它的地位就是一个局部变量，局部变量不能使用修饰符，但可以使用 final

  3. 作用域：仅仅在定义它的方法或代码块中。

  4. 局部内部类 -- 访问 --> 外部类的成员 【直接访问】

     外部类 -- 访问 --> 局部内部类的成员 【创建对象，再访问（必须在作用域内）】

  5. 外部其他类 -- 不能访问 --> 局部内部类

  6. 如果外部类和局部内部类的成员重名时，局部内部类访问的话，默认遵循就近原则。如果想访问外部类的成员，使用【外部类名.this.成员】去访问。

     【外部类名.this】本质就是外部类的对象，即哪个对象调用了【成员】, 【外部类名.this】就是哪个对象

- 匿名内部类

  (1) 本质是类  (2) 内部类  (3) 该类没有名字  (4) 同时还是一个对象

  ```java
  new 类或接口(参数列表) {
      类体
  };
  ```

  1. 匿名内部类 既是一个类的定义，也是一个对象。
  2. 可以直接访问外部类的所有成员，包含私有的。
  3. 不能添加访问修饰符，因为它的地位就是一个局部变量。
  4. 作用域：仅仅在定义它的方法或代码块中。
  5. 匿名内部类 -- 访问 --> 外部类的成员 【直接访问】
  6. 外部其他类 -- 不能访问 --> 匿名内部类
  7. 如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则。如果想访问外部类的成员，使用【外部类名.this.成员】去访问。

- 成员内部类

  1. 可以直接访问外部类的所有成员，包含私有的

  2. 可以添加任意访问修饰符(public、protected 、默认、private)，因为它的地位就是一个成员。

  3. 作用域：和外部类的其他成员一样，为整个类体。比如，在外部类的成员方法中创建成员内部类对象，再调用方法。

  4. 成员内部类 -- 访问 --> 外部类的成员 【直接访问】

     外部类 -- 访问 --> 成员内部类的成员 【创建对象，再访问】

  5. 外部其他类 -- 访问 --> 成员内部类【2种方式】

  6. 如果外部类和成员内部类的成员重名时，成员内部类访问的话，默认遵循就近原则。如果想访问外部类的成员，使用【外部类名.this.成员】去访问。

- 静态内部类

  1. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员。

  2. 可以添加任意访问修饰符(public、protected 、默认、private)，因为它的地位就是一个成员。

  3. 作用域：同其他的成员，为整个类体。

  4. 静态内部类 -- 访问 --> 外部类的成员 【直接访问静态成员】

     外部类 -- 访问 --> 静态内部类的成员 【创建对象，再访问】

  5. 外部其他类 -- 访问 --> 静态内部类【2种方式】

  6. 如果外部类和静态内部类的成员重名时，静态内部类访问的话，默认遵循就近原则。如果想访问外部类的成员，使用【外部类名.成员】去访问。



